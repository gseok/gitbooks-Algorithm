### 세그먼트 트리\(Segment Tree\)

#### 기본 개념 정리

일반적인 트리의 node들이 어떤 값이나 객체를 나타내는 것과 달리, 트리의 node들이 범위을 나타내고 있는 경우, 이를 세그먼트 트리 라고 한다.

![](/assets/segmentTree.png)

그림 출처: [http://blog.naver.com/PostView.nhn?blogId=kks227&logNo=220791986409](http://blog.naver.com/PostView.nhn?blogId=kks227&logNo=220791986409)

예를 들어 어떤 아이템이 0 ~ 7 까지 있다고 가정하자. 그리고 해당 아이템을 구간\(범위\) 별로 더한 값이 필요하다고 가정하자.

이때, 구간이 랜덤하게 주어졌을때, 해당 구간의 값을 구하려면, 항상 구간을 자르고, 해당 구간만큼 더하는 연산이 필요하다.

하지만 위와 같이 세그먼트 트리를 구성하면, 랜덤한 구간이 주어졌을때, 해당 구간에 대한 값을 바로 가져올 수 있다.

**세그먼트 트리의 핵심은, 트리의 노드가 구간을 의미 \(혹은 해당 구간 만큼의 값을 의미\) 한다는 점이다.**

#### 이론 핵심 요약

* 어떤 구간의 값을 나타내는 알고리즘
  * 트리의 요소 \(Item\)은 정해져 있고, 해당 요소의 `범위`\(구간\)에 대한 값\(합, 차, 최소, 최대, 평균, .. 등등\)을 구할 때 사용
  * 트리를 완전 이진 트리\(포화 이진트리\) 형태로 만들어서 풀이한다.
    * 트리의 요소 \(Item\)는 2^a \(2의 a 승\) 형태로 처리 한다.
    * 만약 2^a승 형태가 아닌 경우, dummy을 주어서 항상 2^a인 형태로 처리한다.
  * 트리의 요소가 2^a승 형태가 아닌 경우, HashMap와 같은 자료구조를 사용해서 처리해도 답을 도출 할 수 있다. 다만 array형태를 사용하고 dummy을 주어서 처리하는 것 보다, 속도가 느리다.
  * 복잡도 O\(Log N\)
    * 알고리즘 자체가 logN 의 범주로 되어 있다.\(완전 이진 트리로 봤을때, 깊이는 logN이되고, left자식, right자식, 을 방문하는 형태를 취하면, 2LogN 의 복잡도가 나온다\)

#### 구현 핵심 요약

Java로 설명한다.

##### 필요한 요소

* 문제에서 주어지는 Item을 저장하는 자료구조 \(Array \| List\) - e.g\) `int [] items`
* 세그먼트 트리를 표현하는 자료구조 \(Array \| HashMap\) - e.g\) `SumSegmentTree [] tree`
* 세그먼트 트리의 크기를 계산하는 함수
* 세그먼트 트리를 생성하는 함수
* 세그먼트 트리를 방문\(답을 구하는\)하는 함수

##### 코드

> 세그먼트 트리의 크기를 계산하는 함수

* 세그먼트 트리의 크기 \(전체 노드 수\)는, 문제에서 주어진 Item이 2^a승 형태일 경우 2^\(a + 1\) -1 이다.
  * e.g\) Item이 4개라고한다면, 2^2승 형태가 된다. 따라서 a== 2가 된다. 위 공식에 따라서 2^\(a + 1\) -1 == 2^\(2 + 1\) -1 == 2^3 - 1 이 된다.
  * 2^3 -1\(2의 3승 - 1\) == 7

결과적으로 2^3-1은\(2의 3승 -1\) == 7 이 된다.



```java

```

* 세그먼트 트리를 생성하는 함수
* 세그먼트 트리를 방문\(답을 구하는\)하는 함수

```java

```



